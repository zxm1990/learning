#### 基本内置类型
- C++定义了一套包括算术类型和空类型在内的基本数据类型。
##### 算术类型
- 算术类型分为两类：整型（包括字符和布尔类型）和浮点型
- 一个char的大小应该和一个机器字节一样，最小尺寸是8位
- wchar_t类型用于确保可以存放机器的最大扩展字符集中的任意一个字符。
- char16_t 和 char32_t 则为Unicode字符集服务
- int(16) short(16) long(32) long long(64)其中long long是C++11中新定义的
- 可寻址的最小内存块为字节（byte），存储的基本单元为字（word），它通常由几个字节组成。在C++语言中，一个字节要至少能容纳机器基本字符集中的字符。
- 为了赋予内存中某个地址明确的含义，必须首先知道存储在该地址的数据类型，类型决定了数据所占的比特数以及如果解释这些比特的内容。
- float（32）double（64）long double（96或128），一般来说，类型float和double分别有7和16个有效位。
###### 带符号类型和无符号类型
- int short long 和long long都是带符号类型，前面加unsigned 可以得到无符号类型
- 字符型被分为三种：char、signed char 和 unsigned char。值得注意的是：char和signedchar 并不一样，但是字符的表现形式只有2种，带符号和无符号的，类型char实际上会表现出上述两种形式中的一种，具体哪种由编译器决定。
- 实际中，short（16） int和long一样大（32）
- 在算术表达中不要使用char，不知道其具体表达形式，如果确实需要，请使用signed char 和 unsigned char
- 执行浮点运算选用double，这是因为float通常精度不够，而双精度和单精度运算的计算代价相差无几。
##### 类型转换
- 当我们赋给无符号类型一个超出它表示范围的值时，结果是初始值对无符号类型表示数值总数取模后的余数。取模：n = kp + r ；其中 0 <= r <= p ; -1 = -1 * 256 + 255; 故-1 变为无符号类型是255
- 当我们赋给带符号类型一个超出它表示范围的值时，结果是未定义的。
##### 字面值常量
- 以0开头的整数代表8进制，0x或者0X开头表示16进制。
- 我们使用-42，那个负号不在字面值之内，它的作用仅仅对字面值取负值而已
- 类型short没有对应的字面值
- 浮点型字面值是一个double
- 字符串字面值的类型实际上是由常量字符构成的数组。
#### 变量
##### 变量定义
###### 初始值
- 初始化不是赋值，初始化的含义是创建变量时赋予其一个初始值，而赋值的含义是把对象的当前值擦除，而以一个新值来替代。
###### 列表初始化
```
int sold = 0;
int sold = {0};
int sold{0};
int sold(0);
```
- 当用于内置类型的变量时，列表初始化有个重要的特点：如果我们使用列表初始化且初始值存在丢失的风险，编译器将报错。
```
long double ld = 3.1415926;
int a{ld}, b = {ld};//错误：将丢失信息
int c(ld), d = ld;//正确，确实丢失了信息。
``` 
###### 默认初始化
默认值到底是什么，由变量类型决定，同时定义变量的位置也会对此有影响。
- 内置类型：如果没有被显示初始化，其值由位置决定，任何函数值为的变量被初始化为0，定义函数内部的变量将不被初始化。
- 每个类各自决定其初始化对象的方式，而且，是否允许不经初始化就定义对象也由类自己决定。
##### 变量声明与定义的关系
- 声明：使得名字为程序所知，一个文件如果想要使用别处的定义的名字则必须包含对那个名字的声明
- 定义：负责创建与名字关联的实体
- 变量声明规定了变量的类型和名字，在这一点上定义与之相同，但是除此之外，定义还申请存储空间，也可能回为变量赋一个初值
- 如果想==声明一个变量而非定义它==，就在变量名前添加extern，而且不要显示的初始化变量。==任何包含了显示初始化的声明即成为定义==。
- extern语句如果包含了初始值就不再是声明而是定义了。
- 在函数体内部如果试图初始化一个extern关键字标记的变量，将引发错误
- 变量能且只能被定义一次，但是可以被多次声明
##### 标识符
- c++为标准库保留了一些名字，用户自定义的标识符中不能连续出现2个下划线，也不能以下划线紧连大写字母开头。==函数体外的标识符不能以下划线开头==。
###### 变量命名规范
- 变量名一般用小写字母，index
- 用户自定义的类名一般以大写字母开头。Sales_item
- 标识符之间有多个单词组成，应该又明显的区分。student_load 或 studentLoad 而不要是studentload.
##### 名字的作用域
一般来说，在对象第一次使用的地方附近定义它是一种好的选择，因为这样做有助于更容易找到变量的定义。
###### 嵌套作用域
作用域一旦声明了某个名字，它所嵌套的所有作用域都能访问该名字，同时，允许在内层作用域中重新定义外层作用域的已有的名字。
#### 复合类型
一条声明yu ju语句由一个==基本数据类型和一个声明符列表==组成。（一条语句中定义基本类型和指针）
##### 引用
==定义引用时，程序把引用和它的初始值绑定在一起，而不是将初始值拷贝给引用，一旦初始化完成，引用将和它的初始值一直绑定在一起，因为无法令引用重新绑定到另外一个对象，因此引用必须初始化==。
###### 引用的定义
除了2种例外，其他所有引用的类型都要与之绑定的对象严格匹配，而且，==引用只能绑定到对象上，而不能与字面值或某个表达式的计算结果==绑定在一起。
#### 指针
- 指针本身就是一个对象，允许对指针赋值和拷贝，而且在指针的生命周期内它可以先后指向几个不同的对象。
- 指针无须在定义时赋初值，和其他内置类型一样，在块作用域内定义的指针如果没有被初始化，也将用于一个不确定的值。
###### 获取对象的地址
- 因为引用不是对象，所以不能定义指向引用的指针。
- 除了2中情况外（父类指针指向子类对象），其他所有指针的类型都要和所指向的对象严格匹配。
###### 指针值
指针的值应该时4状态之一  
1. 指向一个对象
2. 指向紧邻对象所占空间的下一位置（迭代器）
3. 空指针，意味指针没有指向任何对象
4. 无效指针，上述情况之外的值

==访问无效指针将引发错误，编译器并不负责检查此类错误。尽管第2种和第3种指针也是有效的，显然它们没有指向任何对象，所以试图访问此类指针对象的行为不被运行。==
###### 空指针
```
int *p1 = nullptr;
int *p2 = 0;
int *p3 = NULL;//#include <cstdlib>
```
预处理变量不属于命名空间，它由预处理器负责管理，因此使用时无需前面加上std::
#### 理解复合类型声明
###### 指向指针的指针
- 指针既然是一个对象，那么就会出现指向指针的指针
- 引用本身不是一个对象，因此不能定义指向引用的指针。但指针是对象，所有存在对指针的引用。
```
int i = 42;
int *p;
int *&r = p;
r = &i;
*r = 0;
```
要理解r的类型是什么，最简单的方法是==从右向左==阅读，离变量名最近的符号对变量有最直接的影响。因此r是一个引用，声明符的其余部分用来确定r引用的类型是什么。r引用的是一个int类型的指针。
#### const限定符
因为const对象一旦被创建后其值就不能被改变，所以const对象必须初始化。
###### 默认状态下，const对象仅在文件内有效
```
const int bufsize = 512;
```
==编译器==将在编译过程中把用到该变量的地方都替换成对应的值。   
如果我们想const变量像非常量一样工作，在一个文件内定义，在其他多个文件内声明并使用它。==const变量不论时定义还是声明都添加extern关键字==。
```
extern const int bufsize = 512; //file_1.cc
extern const int bufsize; //file_1.h
```
#### const的引用
第一种例外情况就是初始化常量引用时允许==任意表达式==作为初始值，只要该表达式的结果能转换成引用类型即可。尤其，允许为一个常量引用绑定非常量对象，字面值，甚至是个一般表达式。
```
int i = 42;
const int &r1 = i;
const int &r2 = 42;
cnost int &r3 = r1 * 3;
```
要理解这种例外情况的原因，弄清楚当一个常量引用被绑定到另外一种类型上时发生了什么。
```
double dval = 3.1415;
const int &ri = dval;
```
==编译器==把上述代码变成。
```
const int temp = dval;//创建一个临时变量
const int &ri = temp;//ri绑定这个临时变量
```
接下来探讨当ri不是常量时，上面的变化会带来什么样的后果？如果ri不是常量，就允许对ri赋值，这样会改变ri所引用对象的值，这个时候改变是临时变量的值，c++将这种行为归为非法。
##### 指针与const
指针的类型必须与其所指对象的类型一致，但是有2种情况例外，第一种是允许令一个指向常量的指针指向一个非常量对象（常量类型与非常量类型是2种不同的类型）  所谓指向常量的指针仅仅要求==不能通过该指针改变对象的值，而没有规定那个对象的值不能通过其他途径改变==。
###### const指针

指针是对象而引用不是，允许把指针本身定为常量，==常量指针==必须初始化，而且一旦初始化，其值就不能被改变。
##### 顶层const
- 顶层const：指针本身是一个常量
- 底层const：指针所指的对象是一个常量
- 更一般的，==顶层const可以表示任意对象是常量，这一点对任何数据类型都适用，如算术类型，类，指针等==。
- 底层const则与==指针和引用等复合类型的基本类型部分有关。
- 不能改变对象本身就是顶层const，能改变就是底层const
```
const int ci = 42; //不能改变ci，顶层const
const int *p = &ci; //能改变p, 底层const
```
- 用于声明引用的const都是底层const.(因为引用不能是顶层const，引用本身就不能改变，只是对象的别名)
##### constexpr和常量表达式
==常量表达式==是指值不会改变并且在编译过程就能得到计算结果的表达式。
```
const int max_files = 20; //常量表达式
const int limit = max_files;//常量表达式
int staff_size = 27;//不是，虽然27是字面值，但数据类型是普通int
const int sz = get_size();//不是
```
###### constexpr 变量
C++11新标准规定，允许将变量声明为==constexpr==类型，以便由编译器来验证变量的值是否是一个常量表达式，声明为constexpr的变量==一定是一个常量，而且必须用常量表达式初始化==。
```
constexpr int mf = 20;
constexpr int limit = mf + 1;
constexpr int sz = size();//只有当size是一个constexpr函数时才是一条正确的声明语句
```
###### 
字面值类型
常量表达式的值需要在==编译==时就得到计算，因此对声明constexpr的类型必须有所限制。----字面值类型   
- 算术类型、引用和指针都是字面值类型    
- 自定义类、IO库、string则不属于字面值类型，也就不能被定义成constexpr
- 尽管指针和引用都能定义成constexpr，但它们的初始值却受到严格限制，一个constexpr指针的初始值必须是nullptr或者0，或者存储于某个固定地址中的对象
- 固定地址对象只有函数体内的static或者函数体外的全局变量
###### 指针和constexpr
在constexpr声明如果定义了一个指针，限定符constexpr仅对指针有效，与指针所指的对象无关
```
const int *p = nullptr;//p是一个指向整型常量的指针
constexpr int *q = nullptr;//q是一个常量指针
```
关键在于==constexpr把它所定义的对象置为了顶层const==。   
constexpr指针既可以指向常量也可以指向非常量。   
==是否可以理解为==
```
constexpr int *ptr  === const int *const ptr
```
#### 处理类型
##### 类型别名
- 使用typedef
```
typedef double wages;//wages 是double的同义词
typedef wages base, *p;//base == double , p == double*
```
- 使用别名声明
```
using SI = sales_item;//SI是别名
```
###### 指针、常量和类型别名
如果类型别名指代是复合类型或常量，那么声明语句就有意思了
```
typedef char *pstring;
const pstring cstr = 0;//cstr是指向char的常量指针。
const pstring *ps;//ps是一个指针，它的对象是指向char的常量指针
```
pstring 实际上是一个指针，因此==const pstring就是指向char的常量指针==。而==非指向常量字符的指针==。
- 如果人们错误的将类型别名替换来理解
```
const char *cstr = 0;//是对const pstring cstr的错误理解
```
这种理解是错误的，声明语句中用到的pstring时，其基本类型是==指针==。可是用char*重写之后，==数据类型变为char，*成为了声明符的一部分==。改写的结果是const char成了基本数据类型。前后两种声明含有截然不同。
##### auto类型说明符
编程时常常需要把表达式的值赋给变量，这就要求在声明变量时候清楚知道表达式类型。C++11新标准引入了auto类型说明符，用它就能让==编译器==替我们去分析表达式所属的类型，auto让编译器通过初始值来推算变量的类型，显然，==auto定义的变量必须有初始值==。
```
auto i = 0, *p = &i;
```
使用auto也能在一条语句中声明多个变量，这条语句中所有变量的初始类型都必须一样。
###### 复合类型、常量和auto


##### decltype类型指示符
希望从表达式的类型推断出要定义的变量的类型，但是不想用该表达式的值初始化变量。decltype选择并返回操作数的操作类型
```
const int ci = 0, &cj = ci;
decltype(ci) x = 0;//const int
decltype(cj) y = x//const int&
decltype(cj) z;//引用必须初始化
```
==引用从来都作为其所指对象的同义词出现，只有用在decltype出是一个例外==。
###### decltype和引用
```
int i = 42, *p = &i, &r = i;
decltype(r + 0) b;//int, 
decltype(*p) c;//错误，int&，必须初始化
```
- 如果表达式的内容是解引用操作，则得到的是引用类型
- 如果decltype使用的是一个不加括号的变量，得到的结果就是该变量的类型
- 如果给变量加一层或多层括号，得到引用类型
```
decltype((i)) e; //错误，int&, 必须初始化  
decltype(i) d;//int
```
#### 自定义数据结构
##### 定义Sales_data类型
- 类内部定义的名字必须唯一，但是可以与类外部的名字重复
- 类体右侧的表示结束的花括号必须写一个分号，这是因为==类体后面可以紧跟变量名以示对该类型对象的定义，所有分号必不可少==。
- 最好不要把==对象的定义和类的定义==放在一起，这么做无异于把两种不同实体的定义混在一条语句里，一会定义类，一会定义变量。显然是一种不被建议的行为。
###### 类数据成员
- C++11新标准规定，可以为数据成员提供一个类内初始值，创建对象时，类内初始值将用于初始化数据成员，没有初始化的成员被默认初始化。
- 对类内初始值的限制，或者放在花括号里，或者放在等号右边，记住==不能使用圆括号==。
##### 编写自己的头文件
- 为了确保各个文件中类的定义一致，类通常被定义在头文件中，而且类所在的头文件的名字应与类的名字一样
- 头文件一旦被改变，相关的源文件必须重新编译以获取更新过的声明

###### 处理器概述
- #define指令把一个名字设定为预处理变量
- #ifdef当且仅当变量已定义时为真
- #ifndef当且仅当变量为定义时为真
- 一旦检查结果为真，则执行后续操作直至遇到#endif为止  
==预处理变量无视C++语言中关于作用域的规则==，这就能解释为什么宏（==预处理==）比const变量（==编译==）更容易被替换。

