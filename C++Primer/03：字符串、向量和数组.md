#### 命名空间的using声明
- 内置类型，比如数字，字符体现了大多数硬件具备的能力，数组的实现也与硬件强相关
###### 头文件不应包含using 声明
头文件的内容会拷贝到所有引用它的文件中去，那么每个使用该头文件的文件都会有这个声明，这样有可能会产生一些名字冲突
#### 标准库类型string
##### 定义和初始化string对象
```
sring s1; // 空字符串
string s2 = "123";
sting s6("123");
string s3 = s2;
string s5(s3);
string s4(10, 'c');//10个c字符
```
###### 直接初始化和拷贝初始化
- 使用=号初始化一个变量，执行的是==拷贝初始化==。
- 不使用=号初始化，执行的是==直接初始化==。
##### string对象上的操作
```
os << s;//将s写到输出os当中，返回os
is >> s;//从is中读取字符串赋给s，字符串以空白分隔，返回is
getline(is, s);//从is中读取一行赋给s, 返回is
s.empty();
s.size();
s[n];
s1+s2;
s1 = s2;
<、>=、 ==、 <、 <= //对大小写敏感
```
###### 读写string对象
- 使用cin读取string时，==自动忽略开头的空白（空格符、换行符、制表符），并从第一个真正的字符开始读起，直到遇见下一处空白为止==。
- 例如“   Hello world  " ，使用cin得到应该是”Hello“
###### 使用getline读取一整行
- getline参数：==输入流==和一个string对象
- 函数从给定的输入流中读入内容，直到遇到==换行符==为止（注意==换行符也被读进来==了）
- 所读的内容存入到string对象中（==注意不存换行符==）
###### string:: size_type类型
- size函数返回的是string:: size_type
- 体现了与机器无关的特性
- 尽管我们不太清楚size_type的细节，但是可以肯定的是它是一个无符号的类型，而且足够存放任何string对象的大小
- 注意如果在表达式混用了==带符号==和==无符号==，可能会产生意想不到的效果
- C++11新标准可以通过auto或者decltype来推断变量的类型
```
atuo len = line.size();
decltype(line.size()) len;
```
###### 字面值和string对象相加
- 标准库允许将==字符字面值==和==字符串字面值==转换为string
- string对象、字符字面值、字符串字面值混在一条语句中，必须确保==每个加法运算符（+）==的两侧运算对象至少有一个string。
- 支持+，string运算符的重载，如果都是字面值，则不能用+了，因为对字面值没有进行运算符重载
```
string s1 = "hello" + "world";//错误，字面值不能直接相加
string s2 = s + "hello" + "world";
string s3 =  "hello" + "world" + s;//错误，运算符的顺序，
```
##### 处理string对象中的字符
在cctype头文件中定义一组标准库函数来处理字符
```
isalnum(c); //c是字母或数字时为真
isalpha(c); //c是字母时为真
iscntrl(c); //c是控制字符时为真
isdigit(c); //c是数字时为真
isgraph(c); //c不是空格但可打印时为真
islower(c); //c是小写字母时为真
isprint(c); //c是可打印字符为真（空格或具可视形式）
ispunct(c); //c是标点符号为真
isspace(c); //c是空白为真(空格、横向或纵向制表符、回车符、换行符、进纸符的一种)
isupper(c); //c是大写字母为真
isxdigit(c); //c是十六进制数字为真
tolower(c); //如果c是大写字母，输出对应小写字母，否则原样输出c
toupper(c); //如果c是小写字母，输出对应大写字母，否则原样输出c
```
###### 建议使用C++版本的C语言标准库头文件
- C语言的头文件形式如 name.h
- C++将这些文件命名为 cname, 也就是==去掉了 .h 后缀，前面添加 字母c==。
- 名为 cname 的头文件定义的名字从属于命名空间std，定义为 .h 头文件则不然
###### 范围for语句
```
for (auto c : str)
    cout << c << endl;
```
- 每次迭代str的下一个字符都会被拷贝到c中
###### 使用范围for语句改变字符串中字符
- 改变string对象中的字符，必须把循环变量定义成引用类型
```
for (auto &c : str)
    c = toupper(c);
```
###### 只处理一部分字符
- 下标运算符接收的输入参数string:: size_type, 返回值是该位置上字符的==引用==。
#### 标准库类型vector
- vector是一个类模板
- 引用不是对象，所以不存在包含引用的vector
##### 定义和初始化vector对象
定义vector对象的方法
```
vector<T> v1; 
vector<T> v2(v1);
vector<T> v2 = v1;
vector<T> v3(n, val);
vector<T> v4(n); //n个重复执行值初始化
vector<T> v5{a, b, c...};
vector<T> v5 = {a, b, c};
```
###### 列表初始化  
在大多数情况下，这些初始化方式可以相互等价使用，不过也并非如此。有2种例外情况。
- 使用拷贝初始化只能提供一个初始值
- 如果提供的是一个类内初始值，则只能使用==拷贝初始化或使用花括号形式==初始化。
- 如果提供的是初始元素列表，则只能把==初始值都放在花括号里进行列表初始化==，而不能放在圆括号
###### 值初始化
只提供vector对象容纳的元素数量而略去初始值，此时库会创建一个==值初始化==的元素初始值。   
值初始化有2个特殊的限制
- 有些类要求必须提供初始值，如果vector对象中元素==不支持默认初始化，只提供数量是不能完成初始化工作==。
- 如果只提供元素的数量而没有设定初始值，只能使用==直接初始化==，不能使用拷贝初始化。
```
vector<int> vi = 10;//错误，必须使用直接初始化
```
###### 列表初始化
- 列表初始化会尽可能把花括号内的值当成是元素初始值的列表来处理，只有在无法执行列表初始化时才会考虑其他初始化方式
- 如果初始化使用了花括号的形式但是提供的值又不能用来列表初始化，就要考虑用这样的值来构造vector对象了
```
vector<string> v5{"hi"}; //列表初始化
vector<string> v6("hi"); //错误，不能使用字符串字面值构造vector对象
vector<string> v7{10}; // 10个默认初始化的元素
vector<string> v8{10, "hi"}; //10个hi
```
###### vector 支持的操作
```
v.empty()
v.size()
v[n]
v1 = v2
v1 = {a, b ,c}
v1 == v2
v1 != v2
<、 <=、 >、 <=
```

#### 迭代器介绍
- 所有的==标准库容器==都可以使用迭代器，但是其中只有少数几种才同时支持下标运算
- 有效迭代器或者指向某个元素，或者指向容器中尾元素的下一位置，其他所有情况都属于无效
##### 使用迭代器
- 如果容器为空，则begin和end返回的是同一个迭代器，都是尾后迭代器
###### 迭代器运算符
- ==标准容器迭代器==的运算符
```
*iter
iter->item
++iter
--iter
iter1 == iter2
iter1 != iter2
```
==注意：这里没有指明+、 -、<、这样的操作符==。
###### 泛型编程
- 对于for循环使用 != 而是 < 的原因。
- ==所有标准库容器的迭代器都定义了 == 和 != ，但是它们中大多数都没有定义 < 运算符==。
###### 迭代器类型
- 如果vector对象或string对象是一个常量，只能使用const_iterator
- 如果vector对象或者string对象不是一个常量，那么既能使用iterator也能使用const_iterator
###### begin 和 end 运算符
- begin 和 end 返回的具体类型由对象是否是常量决定
- 如果对象是常量，返回const_iterator
- 如果对象不是常量，返回iterator
- 有时候迭代器类型由对象来决定，这种行为并非我们所需要的，C++11新标准引入2个新函数，分别是 cbegin 和 cend ，不论对象本身是否是常量，返回值都是const_iterator
##### 迭代器运算
标准库容器支持迭代器递增、==、！=。但是vector和string能支持更多额外的运算
###### vector 和 string 迭代器支持的运算
```
iter + n
iter - n
iter += n
iter -= n
iter1 - iter2
>、 >=、 <、 <=
```
迭代器相减就能得到距离，类型是 ==difference_type==，这个距离可正可负，故是==带符号的类型==。
#### 数组
##### 定义和初始化内置数组
- 数组中元素的个数也属于数组类型的一部分，==编译==的时候维度应该是已知的，就是说，维度必须是一个常量表达式
```
unsigned cnt = 42;
constexpr unsigned sz = 42; 
int arr[10];
int *parr[sz];
string bad[cnt]; //错误
string strs[get_size()]; //当get_size是constexpr时，才正确
```
和内置类型一样，如果在函数内部定义了某种内置类型的数组，那么==默认初始化==会令数组含有为==未定义的值==。
- 数组的元素应为对象，因此==不存在引用==的数组
###### 显示初始化数组
- 如果维度比提供的初始值数量大，提供的初始值初始化靠前的元素，剩下的元素执行==值初始化==。
```
const unsigned sz = 3;
int ia[sz] = {1, 2, 3};
int a3[5] = {1, 2, 3}; //值初始化，{1, 2, 3, 0, 0}
```
###### 字符数组的特殊性
- 允许使用字符串字面值对数组进行初始化，注意的是字符串结尾的空字符也会拷贝到字符数组中
###### 不允许拷贝和赋值
- 不能将数组的内容拷贝给其他数组作为初始值，也不能用数组为其他数组赋值
###### 理解复杂的数组声明
数组本身是对象，所有允许定义数组的指针及数组的引用
```
int *ptrs[10]; //右向左，10个指针的数组
int &refs[10]; //错误，引用不是对象
int (*parray)[10] = &arr; //内向外读，指针，指向含有10个整数的数组
int (&arrRef)[10] = arr;  //内向外读，引用，指向含有10个整数的数组
```
##### 访问数组元素
- 数组下标类型size_t, 头文件cstddef中定义
##### 指针和数组
- 在==很多用到数组名字==的地方，编译器都会自动将其替换为一个==指向数组首元素的指针==。
- 一层隐含的意思当使用数组作为一个auto变量的初始值时，推断得到的类型是==指针而非数组==。
```
int ia[] = {1, 2};
auto ia2(ia);
ia2 = 10; // ia2是指针，不能用int给指针赋值
```
- 当使用decltype关键字时，上述转换不会发生。
```
decltype(ia) ia3 = {3, 4};
```
###### 标准库函数begin 和 end
- 数组不是类类型，因此这2个函数并不是成员函数
```
int ia[] = {1, 2, 3, 4};
int *beg = begin(ia);
int *last = end(ia); //尾元素的下一位置指针
```
- 这2个函数定义在iterator 头文件中
###### 指针运算
- 两个指针相减的结果类型是一种名为 ptrdiff_t 标准类型
- 和size_t 一样，ptrdiff_t 也定义在cstddef头文件中
- ptrdiff_t 是差值，可正可负，故是一种带符号的类型
###### 下标和指针
- 虽然标准库vector和string也能执行下标运算，但是数组与它们相比还是有所不同，==标准库类型限定使用的下标必须是无符号类型==，而==内置的下标运算无此要求==。
```
int *p = &ia[2];
int j = p[1];
int k = p[-2]; //数组的下标可以为负数
```
#### C风格字符串
- C风格字符串==不是一种类型==，而是为了表达和使用字符串而形成的一种约定俗成的写法
###### C标准库String函数
- 这些函数定义在cstring头文件中，是string.h 转换到C++版本
```
strlen(p)
strcmp(p1, p2)
strcat(p1, p2)
strcpy(p1, p2)
```
- 传入此类函数的指针==必须指向以空字符作为结束的数组==。
#### 与旧代码的接口
###### 混用string对象和C风格字符串
- 任何出现字符串字面值的地方都可以用以空字符结束的字符数组来替代
- 允许使用以空字符结束的字符数组来初始化string对象或为string对象赋值
- 在string对象的加法运算中允许使用一空字符结束的字符串数组作为其中一个运算对象（==不能两个运算对象都是==），
- 上述性质反过来就不成了，如果需要C风格字符串，无法直接使用string对象来代替
```
char *str = s; //错误，不能直接使用string
const char *str = s.c_str(); //空字符串结束的字符数组
```
###### 使用数组初始化vector对象
以前介绍过
- 不允许使用数组为另一个内置类型的数组赋初值
- 不允许使用vector对象初始化数组
- 相反，允许使用数组来初始化vector对象
```
int int_arr[] = {1, 2, 3, 4};
vector<int> ivec(begin(int_arr), end(int_arr));
// 也可以只取数组的一部分
vector<int> subVec(int_arr + 1, int_arr + 4); // 第二个到第四个
```
#### 多维数组
- C++语言中没有多维数组，通常所说的多维数组其实是数组的数组
- 当一个数组的元素仍是数组时，通常使用两个维度来定义它，一个维度表示==数组本身的大小==，另外一个维度表示==其元素（数组）的大小==。
```
//大小为10的数组，它的每个元素都是大小为20的数组
//这些数组元素含有30个整数的数组
int arr[10][20][30] = {0};
```
###### 多维数组的下标引用
- 如果表达式含有的下标运算符数量和数组的维度一样多，该表达式的结果将是给定类型的元素
- 如果表达式含有的下标运算符数量比数组维度下，则表达式的结果将是给定索引处的一个内层数组
```
int ia[3][4];
int arr[10][20][30];
ia[2][3] = arr[0][0][0]; //下标运算与数组维度都相同
int (&row)[4] = ia[1]; //ia的下标运算比数组维度下，表明是一个数组
```
###### 使用范围for语句处理多维数组
```
size_t cnt = 0;
for (auto &row : ia)
    for (auto &col : row)
    {
        col = cnt;
        ++cnt;
    }
```
这里由于要改变数组的值，所以我们将row和col都声明成引用类型。
- 但是如果不改变数组的内容，也需要将row声明成引用类型。（auto 会将数组推断成指针）
- 如果被推断成指针，会导致下层循环不能编译
- ==使用范围for语句处理多维数组，除了最内层循环外，其他所有循环的控制变量应该是引用类型==。
###### 指针和多维数组
- 多维数组名转换得来的指针实际上指向第一个内层数组的指针
```
int ia[3][4];
int (*p)[4] = ia;

for (auto p = ia; p != ia + 3; ++p)
    for(auto q = *p; q != *p + 4; ++q)
//此时p指向含有4个元素的数组
```
###### 类型别名简化多维数组的指针
```
using int_arry = int[4];
typedef int int_arry[4];

for (int_arry *p = ia;  p != ia + 3; ++p)
    for(int *q = *p; q != *p + 4; ++q)
```

